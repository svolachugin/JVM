### Домашнее задание по теме "JVM. Организация памяти, сборщики мусора, VisualVM"
___
#### Код для исследования происходящего с точки зрения JVM

```{java} {
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

#### Этапы выполнения нашей программы JvmComprehension:
1. Загрузка классов
2. Работа программы, области памяти переменных
3. Работа сборщика мусора

#### Загрузка классов
При запуске программы (скомпилированного байт-кода в формате _.class_) происходит загрузка классов – запускаются загрузчики классов. Сначала запускается загрузчик ***System ClassLoader***, происходит поиск класса в кэше загрузчика, если он найден, то будет возвращен объект этого класса, в противном случае будет запущен следующий загрузчик – ***Extension ClassLoader***. Аналогично с ***System ClassLoader***, либо возвращается объект класса, при наличии класса в кэше загрузчика, либо передается управление загрузчику ***Bootstrap***. Алгоритм действий ***Bootstrap*** такой же, как и у предыдущих загрузчиков.

Если в кэше ***Bootstrap*** класс не найден, то предпринимается попытка его загрузить, если попытка неудачна – класс загрузчиком не найден, запускается загрузчик ***Extension ClassLoader***. При неудаче затем запускается ***System ClassLoader***. Если и тут попытка загрузки не удалась – генерируется исключение. При удачной загрузке каким-либо загрузчиком возвращается объект нужного класса, и запуск последующих загрузчиков не происходит.

Также существуют пользовательские загрузчики, которые пытаются загрузить класс уже после ***System ClassLoader***.

После того, как класс загружен, происходит его связывание – ***Linking*** (проверка, подготовка и разрешение символьных ссылок) и инициализация – ***Initialization***.

#### Работа программы, области памяти переменных
Загрузка всех мета-данных (данные о классе – имя, методы, поля.., константы) классов `main` и `printAll` происходит в ***Metaspace***.
В момент вызова класса `main`:
- создаётся фрейм (кадр) в стеке;
- //1: в стек помещаются примитив `i` и его значение `1`;
- //2: в стек помещается ссылка на объект `o`, в кучу – сам объект и значение `null`;
- //3: в стек помещается ссылка на объект-обертку `ii`, в кучу – сам объект и значение `2`;
- //4: вызывается класс `printAll`, при этом:
    - создаётся фрейм (кадр) в стеке;
    - //5: в стек помещается ссылка на объект-обертку `uselessVar`, в кучу – сам объект и значение `700`;
    - //6: команда `System.out.println` из стека получает значение примитива `i`, а также ссылки на объекты `o` и `ii`, на них из кучи получает значение данных объектов, после чего происходит конкатенация строки `o.toString()`, объекта-обертки `ii` и примитива `i` и вывод ее в консоль (//6);
- //7: команда `System.out.println` выводит в консоль строку `"finished"`.

#### Работа сборщика мусора
Пока наше Java-приложение работает, в нем создаются новые примитивы и объекты – `int i`, `Object o`, `Integer ii`, `Integer uselessVar`. Некоторые объекты перестают быть нужны. То есть в любой момент времени память кучи состоит из двух типов объектов – живые и мертвые.

В нашем случае:
- `int i`, `Object o`, `Integer ii` – живые (есть ссылки на них);
- `Integer uselessVar` – мертвый (нигде не используется – ссылок на него нет).

Сборщик мусора ***Garbage Collector*** находит неиспользуемые (мертвые) объекты и удаляет их, чтобы освободить память.
